<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DocuLatte — Perfectly Brewed Markdown, Ready to Share</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial;
        overflow: hidden;
      }
      .app {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto 1fr auto;
        height: 100%;
      }
      header,
      footer {
        grid-column: 1 / -1;
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #ddd;
      }
      footer {
        border-top: 1px solid #ddd;
        border-bottom: none;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      textarea {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
        padding: 0.75rem;
        resize: none;
        font-family: ui-monospace, Consolas, monospace;
      }
      .col {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .bar {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        padding: 0.5rem;
        border-bottom: 1px solid #eee;
        flex-wrap: wrap;
      }
      .preview {
        padding: 0.75rem;
        overflow: auto;
      }
      .diff {
        padding: 0.5rem;
        white-space: pre-wrap;
        font-family: ui-monospace, Consolas, monospace;
        overflow: auto;
        border-top: 1px dashed #ddd;
      }
      .add {
        background: #e8f5e9;
      }
      .del {
        background: #ffebee;
        text-decoration: line-through;
      }
      .muted {
        opacity: 0.6;
      }
      button {
        padding: 0.4rem 0.6rem;
        border: 1px solid #ccc;
        background: #f7f7f7;
        border-radius: 0.4rem;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      input[type="file"] {
        max-width: 210px;
      }

      /* ================= Keyboard-inspired theme ================= */
      :root {
        /* Coffee/amber palette */
        --sand-50: #fffaf3;
        --sand-100: #fff6ec;
        --sand-150: #fbefe2;
        --sand-200: #f3e5d5;
        --sand-300: #e9d7c3;
        --sand-400: #ddc5aa;
        --cocoa-700: #7b5635;
        --cocoa-800: #6b4b30;
        --cocoa-900: #4e361f;
        --amber-500: #c4945d;
        --amber-600: #b37f45;
        --amber-700: #996a36;
        --ink: #2b1f18;
      }
      body {
        background: linear-gradient(180deg, #efe3d3, #e6d5c3);
        color: var(--ink);
        overflow: hidden;
      }
      .app {
        margin: 18px;
        gap: 0;
        border-radius: 12px;
        background: var(--sand-200);
        border: 8px solid var(--cocoa-800);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.18),
          0 0 0 2px rgba(0, 0, 0, 0.08);
        height: calc(100dvh - 36px);
        display: grid;
        grid-template-columns: 1fr 8px 1fr;
        grid-template-rows: auto 1fr auto;
      }
      header,
      footer {
        background: transparent;
        border-color: rgba(0, 0, 0, 0.2);
      }
      header {
        background: linear-gradient(180deg, var(--amber-500), var(--amber-700));
        color: #2a1b12;
        border-bottom: 1px solid rgba(0, 0, 0, 0.25);
        letter-spacing: 0.02em;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand strong {
        font-weight: 800;
        font-size: 16px;
        text-shadow: 0 1px 0 rgba(255, 238, 220, 0.6), 0 -1px 0 rgba(0, 0, 0, 0.15);
      }
      .tagline {
        font-size: 11px;
        opacity: 0.8;
        font-style: italic;
        font-weight: 400;
        letter-spacing: 0.3px;
      }
      .bar {
        background: linear-gradient(180deg, var(--sand-100), var(--sand-200));
        border-bottom: 1px solid rgba(153, 106, 54, 0.45);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), inset 0 -1px 0 rgba(0, 0, 0, 0.06);
        flex-shrink: 0;
      }
      .col {
        background: var(--sand-200);
        min-height: 0;
        overflow: hidden;
      }
      .left {
        grid-column: 1;
        display: flex;
        flex-direction: column;
      }
      .right {
        grid-column: 3;
        display: flex;
        flex-direction: column;
      }
      .gutter {
        grid-column: 2;
        background: linear-gradient(180deg, #d9c5ac, #cdb493);
        cursor: col-resize;
        position: relative;
      }
      .gutter::before {
        content: "";
        position: absolute;
        top: 0;
        bottom: 0;
        left: 50%;
        width: 2px;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.18);
      }
      .gutter:hover {
        background: linear-gradient(180deg, #e8d6be, #d4bb9c);
      }
      .gutter:active::before {
        background: rgba(0, 0, 0, 0.3);
      }
      textarea,
      .preview,
      .diff {
        background: var(--sand-50);
        color: var(--ink);
        border-radius: 8px;
        border: 1px solid var(--sand-400);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -2px 6px rgba(0, 0, 0, 0.06);
      }
      .col > textarea,
      .col > .preview {
        flex: 1 1 auto;
        min-height: 0;
      }
      .col > textarea {
        height: auto;
      }
      textarea {
        overflow: auto;
      }
      .preview {
        position: relative;
        overflow: auto;
      }
      .diff {
        background: var(--sand-150);
        overflow: auto;
        flex: 0 0 auto;
        max-height: 40%;
        margin-top: 0.5rem;
      }
      .add {
        background: #e8f4ea;
      }
      .del {
        background: #fae9ea;
        text-decoration: line-through;
      }

      /* Keycap-like controls */
      button,
      input[type="file"]::file-selector-button {
        background: linear-gradient(180deg, var(--sand-100), var(--sand-200));
        color: var(--ink);
        border: 1px solid rgba(153, 106, 54, 0.35);
        border-radius: 8px;
        padding: 0.46rem 0.7rem;
        box-shadow: 0 2px 0 rgba(78, 54, 31, 0.5), 0 8px 16px rgba(0, 0, 0, 0.15);
        transition: transform 0.05s ease, box-shadow 0.05s ease, filter 0.15s ease, border-color 0.15s ease;
        font-size: 14px;
        font-family: inherit;
        cursor: pointer;
      }
      button:hover,
      input[type="file"]::file-selector-button:hover {
        filter: saturate(1.03);
        border-color: rgba(153, 106, 54, 0.6);
      }
      button:active,
      input[type="file"]::file-selector-button:active {
        transform: translateY(1px);
        box-shadow: 0 1px 0 rgba(78, 54, 31, 0.55), 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      #saveSnapBtn {
        background: linear-gradient(180deg, #ffe9cf, #f5d3a9);
        border-color: rgba(179, 127, 69, 0.6);
      }

      input[type="file"] {
        max-width: 240px;
        color: var(--ink);
        background: transparent;
        border: none;
      }
      input[type="file"]::file-selector-button {
        margin-right: 0.5rem;
      }

      /* Typography - GitHub README style */
      .preview {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        line-height: 1.6;
      }
      .preview h1,
      .preview h2,
      .preview h3,
      .preview h4,
      .preview h5,
      .preview h6 {
        color: var(--cocoa-800);
        margin-top: 24px;
        margin-bottom: 16px;
        font-weight: 600;
        line-height: 1.25;
      }
      .preview h1 {
        border-bottom: 1px solid #d0d7de;
        padding-bottom: 0.3em;
      }
      .preview h2 {
        border-bottom: 1px solid #d0d7de;
        padding-bottom: 0.3em;
      }
      .preview p {
        margin-bottom: 16px;
      }
      /* Warm bread-style code blocks */
      .preview code {
        background: linear-gradient(135deg, #f4e9d9, #ede0cf);
        color: #6b4423;
        border-radius: 4px;
        padding: 0.15em 0.4em;
        font-size: 85%;
        font-family: "SF Mono", "Monaco", "Inconsolata", "Roboto Mono", "Consolas", "Courier New", monospace;
        border: 1px solid #d4bb9c;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 1px 2px rgba(107, 68, 35, 0.1);
      }
      .preview pre {
        background: linear-gradient(135deg, #f7f0e6, #f0e5d8, #e8dcc6);
        color: #5d4037;
        border-radius: 8px;
        padding: 16px;
        overflow: auto;
        font-size: 13px;
        line-height: 0.95;
        border: 2px solid #d7c4a7;
        margin: 16px 0;
        position: relative;
        box-shadow: 0 2px 8px rgba(107, 68, 35, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.4),
          inset 0 -1px 0 rgba(107, 68, 35, 0.1);
        font-family: "SF Mono", "Monaco", "Inconsolata", "Roboto Mono", "Consolas", "Courier New", monospace;
      }
      .preview pre::before {
        content: "☕ ☕ ☕";
        position: absolute;
        top: 8px;
        left: 12px;
        color: #8d6e63;
        font-size: 12px;
        opacity: 0.6;
      }
      .preview pre::after {
        content: "latte";
        position: absolute;
        top: 6px;
        right: 12px;
        color: #8d6e63;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.4;
      }
      .preview pre code {
        background: transparent;
        color: inherit;
        padding: 0;
        border-radius: 0;
        font-size: inherit;
        line-height: inherit;
        border: none;
        box-shadow: none;
        display: block;
        margin-top: 8px;
      }
      /* Warm latte syntax highlighting */
      .preview pre .comment {
        color: #a1887f;
        font-style: italic;
      }
      .preview pre .keyword {
        color: #8d4e2a;
        font-weight: bold;
      }
      .preview pre .string {
        color: #6f4f28;
      }
      .preview pre .function {
        color: #7b5635;
      }
      .preview a {
        color: #0969da;
        text-decoration: none;
      }
      .preview a:hover {
        text-decoration: underline;
      }
      .preview table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-bottom: 16px;
        border: 1px solid #d0d7de;
      }
      .preview th,
      .preview td {
        padding: 6px 13px;
        border: 1px solid #d0d7de;
        text-align: left;
      }
      .preview th {
        background-color: #f6f8fa;
        font-weight: 600;
      }
      .preview tr:nth-child(2n) {
        background-color: #f6f8fa;
      }
      .preview ul,
      .preview ol {
        margin-bottom: 16px;
        padding-left: 2em;
      }
      .preview li {
        margin-bottom: 0.25em;
      }
      .preview ul.task-list {
        list-style: none;
        padding-left: 0;
      }
      .preview ul.task-list li {
        margin-left: 0;
      }
      .preview ul.task-list input[type="checkbox"] {
        margin-right: 0.5em;
      }
      .preview blockquote {
        padding: 0 1em;
        color: #656d76;
        border-left: 0.25em solid #d0d7de;
        margin: 0 0 16px 0;
      }
      .preview hr {
        height: 0.25em;
        padding: 0;
        margin: 24px 0;
        background-color: #d0d7de;
        border: 0;
      }
      .preview img {
        max-width: 100%;
        height: auto;
        border-radius: 6px;
        margin: 8px 0;
      }

      /* Scrollbars (WebKit/Blink) */
      *::-webkit-scrollbar {
        height: 10px;
        width: 10px;
      }
      *::-webkit-scrollbar-track {
        background: var(--sand-150);
      }
      *::-webkit-scrollbar-thumb {
        background: var(--amber-500);
        border: 2px solid var(--sand-150);
        border-radius: 8px;
      }
      *::-webkit-scrollbar-thumb:hover {
        background: var(--amber-600);
      }

      /* Layout toggle */
      .layout-toggle {
        display: flex;
        gap: 0.25rem;
      }
      .seg {
        background: linear-gradient(180deg, var(--sand-100), var(--sand-200));
        border: 1px solid rgba(153, 106, 54, 0.45);
        padding: 0.35rem 0.6rem;
        border-radius: 0.5rem;
        cursor: pointer;
        box-shadow: 0 1px 0 rgba(78, 54, 31, 0.4);
      }
      .seg[aria-pressed="true"] {
        background: linear-gradient(180deg, #ffe9cf, #f5d3a9);
        border-color: rgba(179, 127, 69, 0.6);
      }

      /* Single-pane layouts */
      .app[data-layout="left"] {
        grid-template-columns: 1fr;
      }
      .app[data-layout="left"] .right,
      .app[data-layout="left"] .gutter {
        display: none;
      }
      .app[data-layout="left"] .left {
        grid-column: 1;
      }
      .app[data-layout="right"] {
        grid-template-columns: 1fr;
      }
      .app[data-layout="right"] .left,
      .app[data-layout="right"] .gutter {
        display: none;
      }
      .app[data-layout="right"] .right {
        grid-column: 1;
      }

      /* Layout tweaks on small screens */
      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
          grid-template-rows: auto 1fr auto 1fr auto;
          margin: 12px auto;
          height: calc(100dvh - 24px);
        }
        .gutter {
          display: none;
        }
        .bar {
          border-radius: 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app" data-layout="split">
      <header>
        <div class="brand">
          <strong>DocuLatte ☕ </strong>
          <span class="tagline">Perfectly Brewed Markdown, Ready to Share</span>
        </div>
        <div class="layout-toggle" role="group" aria-label="Layout">
          <button class="seg" id="layoutLeft" aria-pressed="false" title="Code view">Code</button>
          <button class="seg" id="layoutSplit" aria-pressed="true" title="Split view">Split</button>
          <button class="seg" id="layoutRight" aria-pressed="false" title="Preview view">Preview</button>
        </div>
      </header>

      <div class="col left">
        <div class="bar">
          <input type="file" id="fileIn" accept=".md,.markdown,.txt" />
          <button id="newBtn">New</button>
          <span class="muted">Edit Markdown</span>
        </div>
        <textarea id="editor" placeholder="# Start typing…"></textarea>
      </div>

      <div class="gutter" id="gutter"></div>

      <div class="col right">
        <div class="bar">
          <button id="saveSnapBtn" title="Save a snapshot into the file’s hidden history">Save Snapshot</button>
          <button id="diffLastTwoBtn">Diff: Last Two</button>
          <button id="diffWorkingVsLastBtn">Diff: Working vs Last</button>
          <button id="downloadBtn">Download .md</button>
          <button id="shareBtn" title="Copy encoded .md (with history) to clipboard">Share</button>
          <span id="status" class="muted"></span>
        </div>
        <div id="preview" class="preview"></div>
        <div id="diff" class="diff" hidden></div>
      </div>

      <footer>
        <span class="muted">History is appended at EOF inside an HTML comment. Text-only. No server.</span>
      </footer>
    </div>

    <script>
      // =================== Config ===================
      const START = "MDHISTORY:v1";
      const END = "END-MDHISTORY";

      // =================== Utils ===================
      // UTF-8 safe base64
      const b64enc = (str) => {
        const bytes = new TextEncoder().encode(str);
        let bin = "";
        bytes.forEach((b) => (bin += String.fromCharCode(b)));
        return btoa(bin);
      };
      const b64dec = (b64) => {
        try {
          const bin = atob(b64);
          const bytes = Uint8Array.from(bin, (c) => c.charCodeAt(0));
          return new TextDecoder().decode(bytes);
        } catch {
          return "";
        }
      };

      // Base64url for bytes
      const b64urlFromBytes = (bytes) => {
        let bin = "";
        bytes.forEach((b) => (bin += String.fromCharCode(b)));
        return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      };
      const bytesFromB64url = (b64u) => {
        let s = b64u.replace(/-/g, "+").replace(/_/g, "/");
        const pad = s.length % 4;
        if (pad) s += "====".slice(pad);
        const bin = atob(s);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr;
      };

      // Gzip helpers using built-ins (fallbacks handled at call sites)
      async function gzipString(str) {
        const enc = new TextEncoder().encode(str);
        const cs = new CompressionStream("gzip");
        const stream = new Blob([enc]).stream().pipeThrough(cs);
        const buf = await new Response(stream).arrayBuffer();
        return new Uint8Array(buf);
      }
      async function gunzipBytes(bytes) {
        const ds = new DecompressionStream("gzip");
        const stream = new Blob([bytes]).stream().pipeThrough(ds);
        const buf = await new Response(stream).arrayBuffer();
        return new Uint8Array(buf);
      }

      // Robust GitHub-style Markdown renderer with proper spacing
      function mdToHtml(md) {
        // Normalize line endings
        let html = md.replace(/\r\n?/g, "\n");

        // Process in order: code blocks first to protect content
        html = processCodeBlocks(html);
        html = processImages(html);
        html = processLinks(html);
        html = processTables(html);
        html = processHeaders(html);
        html = processTextFormatting(html);
        html = processLists(html);
        html = processBlockquotes(html);
        html = processHorizontalRules(html);
        html = processParagraphs(html);

        return html;
      }

      function processCodeBlocks(text) {
        // Simple code blocks - just clean boxes, no language-specific formatting
        return text.replace(/```[\w]*\n([\s\S]*?)```/g, (match, code) => {
          // Just preserve whitespace and create simple code block
          return `<pre><code>${esc(code)}</code></pre>`;
        });
      }

      function processImages(text) {
        return text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_, alt, src) => {
          return `<img src="${esc(src)}" alt="${esc(alt)}" style="max-width: 100%; height: auto;" />`;
        });
      }

      function processLinks(text) {
        return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, linkText, url) => {
          return `<a href="${esc(url)}" target="_blank" rel="noopener">${esc(linkText)}</a>`;
        });
      }

      function processTables(text) {
        return text.replace(/((?:^|\n)\|.+\|(?:\n\|.+\|)*)/g, (match) => {
          const lines = match.trim().split("\n");
          if (lines.length < 2) return match;

          const headerRow = lines[0];
          const separatorRow = lines[1];
          const dataRows = lines.slice(2);

          if (!/^\|[\s\-:|]+\|$/.test(separatorRow)) return match;

          let table = "<table>\n<thead>\n<tr>";
          headerRow
            .split("|")
            .slice(1, -1)
            .forEach((cell) => {
              table += `<th>${esc(cell.trim())}</th>`;
            });
          table += "</tr>\n</thead>\n<tbody>\n";

          dataRows.forEach((row) => {
            table += "<tr>";
            row
              .split("|")
              .slice(1, -1)
              .forEach((cell) => {
                table += `<td>${esc(cell.trim())}</td>`;
              });
            table += "</tr>\n";
          });
          table += "</tbody>\n</table>";
          return table;
        });
      }

      function processHeaders(text) {
        return text
          .replace(/^###### (.*)$/gm, "<h6>$1</h6>")
          .replace(/^##### (.*)$/gm, "<h5>$1</h5>")
          .replace(/^#### (.*)$/gm, "<h4>$1</h4>")
          .replace(/^### (.*)$/gm, "<h3>$1</h3>")
          .replace(/^## (.*)$/gm, "<h2>$1</h2>")
          .replace(/^# (.*)$/gm, "<h1>$1</h1>");
      }

      function processTextFormatting(text) {
        // Inline code first
        text = text.replace(/`([^`]+)`/g, (_, code) => `<code>${esc(code)}</code>`);

        // Strikethrough
        text = text.replace(/~~([^~]+)~~/g, "<del>$1</del>");

        // Bold and italic
        text = text.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        text = text.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        return text;
      }

      function processLists(text) {
        // Task lists
        text = text.replace(/(^|\n)- \[( |x)\] (.*)(?=\n|$)/g, (m, pre, checked, item) => {
          const isChecked = checked === "x" ? "checked" : "";
          return `${pre}<ul class="task-list"><li><input type="checkbox" ${isChecked} disabled> ${esc(item)}</li></ul>`;
        });

        // Numbered lists
        text = text.replace(/(^|\n)(\d+)\. (.*)(?=\n(?!\d+\. )|$)/g, (m, pre, num, item) => {
          return `${pre}<ol><li>${item}</li></ol>`;
        });

        // Bullet lists
        text = text.replace(/(^|\n)- (.*)(?=\n(?!- )|$)/g, (m, pre, item) => {
          return `${pre}<ul><li>${item}</li></ul>`;
        });

        // Merge consecutive lists
        text = text.replace(/<\/(ol|ul)>\n<\1>/g, "");

        return text;
      }

      function processBlockquotes(text) {
        text = text.replace(/(^|\n)> (.*)(?=\n(?!> )|$)/g, (m, pre, quote) => {
          return `${pre}<blockquote><p>${quote}</p></blockquote>`;
        });
        text = text.replace(/<\/blockquote>\n<blockquote>/g, "");
        return text;
      }

      function processHorizontalRules(text) {
        return text.replace(/^(---+|___+|\*\*\*+)$/gm, "<hr>");
      }

      function processParagraphs(text) {
        return text.replace(
          /(^|\n)(?!<h\d|<ul|<ol|<pre>|<table|<blockquote|<hr|<\/|<code>)([^\n]+)(?=\n|$)/g,
          (m, pre, line) => {
            if (!line.trim()) return m;
            return `${pre}<p>${line}</p>`;
          }
        );
      }
      const esc = (x) => x.replace(/[&<>]/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[m]));

      // =================== History (snapshots) ===================
      function extractHistoryBlock(md) {
        const re = new RegExp(`<!--\\s*${START}[\\s\\S]*?${END}\\s*-->\\s*$`);
        const m = md.match(re);
        return m ? m[0] : null;
      }
      function stripHistory(md) {
        const blk = extractHistoryBlock(md);
        return blk ? md.slice(0, md.lastIndexOf(blk)).trimEnd() : md.trimEnd?.() ?? md;
      }
      function parseHistory(md) {
        const block = extractHistoryBlock(md);
        if (!block) return [];
        const body = block.replace(/^<!--\s*|\s*-->$/g, "");
        const lines = body.split("\n").slice(1, -1); // between header/footer
        return lines.filter(Boolean).map((line) => {
          // ts|type=snap|enc=b64|data=...
          const parts = line.split("|");
          const meta = {};
          for (const p of parts) {
            const [k, v] = p.includes("=") ? p.split("=", 2) : ["timestamp", p];
            meta[k] = v;
          }
          return meta;
        });
      }
      function renderHistoryBlock(entries) {
        const lines = [
          "<!--",
          START,
          ...entries.map((e) => `${e.timestamp}|type=${e.type}|enc=${e.enc}|data=${e.data}`),
          END,
          "-->",
        ];
        return lines.join("\n");
      }
      function makeSnapshotEntry(currentText) {
        return {
          timestamp: new Date().toISOString(),
          type: "snap",
          enc: "b64",
          data: b64enc(currentText.replace(/\r\n/g, "\n")),
        };
      }
      function lastTwoSnapshots(md) {
        const snaps = parseHistory(md).filter((e) => e.type === "snap");
        if (snaps.length < 2) return null;
        const a = b64dec(snaps[snaps.length - 2].data);
        const b = b64dec(snaps[snaps.length - 1].data);
        return { a, b };
      }
      function lastSnapshotText(md) {
        const snaps = parseHistory(md).filter((e) => e.type === "snap");
        if (!snaps.length) return null;
        return b64dec(snaps[snaps.length - 1].data);
      }

      // =================== Diff (line-level 80/20) ===================
      function lineDiff(before, after) {
        const A = (before ?? "").split("\n"),
          B = (after ?? "").split("\n");
        const n = Math.max(A.length, B.length);
        let out = "";
        for (let i = 0; i < n; i++) {
          const a = A[i] ?? "",
            b = B[i] ?? "";
          if (a === b) out += a + "\n";
          else {
            if (a) out += `\u2212 ${a}\n`; // minus
            if (b) out += `+ ${b}\n`;
          }
        }
        return out.trimEnd();
      }
      function renderDiffColored(diffText) {
        return diffText
          .split("\n")
          .map((line) => {
            if (line.startsWith("+ ")) return `<div class="add">${esc(line)}</div>`;
            if (line.startsWith("− ") || line.startsWith("– ") || line.startsWith("- "))
              return `<div class="del">${esc(line)}</div>`;
            return `<div>${esc(line)}</div>`;
          })
          .join("");
      }

      // =================== UI wiring ===================
      const editor = document.getElementById("editor");
      const preview = document.getElementById("preview");
      const diffEl = document.getElementById("diff");
      const appEl = document.querySelector(".app");
      const gutter = document.getElementById("gutter");
      const layoutLeftBtn = document.getElementById("layoutLeft");
      const layoutSplitBtn = document.getElementById("layoutSplit");
      const layoutRightBtn = document.getElementById("layoutRight");
      const fileIn = document.getElementById("fileIn");
      const newBtn = document.getElementById("newBtn");
      const saveSnapBtn = document.getElementById("saveSnapBtn");
      const diffLastTwoBtn = document.getElementById("diffLastTwoBtn");
      const diffWorkingVsLastBtn = document.getElementById("diffWorkingVsLastBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const shareBtn = document.getElementById("shareBtn");
      const status = document.getElementById("status");

      let currentMd = `# DocuLatte ☕: Comprehensive Overview
### Date: ${new Date().toISOString().split("T")[0]}

DocuLatte is an intuitive markdown editor designed to offer a seamless writing and preview experience with GitHub-style rendering. This document showcases the comprehensive features of DocuLatte, your perfectly brewed markdown companion.

---

## ✨ Core Features

### 💾 Smart Document Management
- **Instant Snapshots:** Save document versions with timestamp tracking
- **Intelligent Diff:** Compare changes between versions with visual highlighting
- **Easy Sharing:** Generate shareable links that open directly in preview mode
- **File Import/Export:** Load existing markdown files or download your work

---

## 🛠️ Technical Capabilities

### Code Blocks with Syntax Highlighting

DocuLatte supports code blocks with language-specific formatting:

\`\`\`javascript
// Example: React component with hooks
import { useState, useEffect } from 'react';

function MarkdownEditor() {
  const [content, setContent] = useState('# Hello DocuLatte!');
  
  useEffect(() => {
    console.log('Content updated:', content);
  }, [content]);
  
  return (
    <textarea 
      value={content}
      onChange={(e) => setContent(e.target.value)}
      placeholder="Start brewing your markdown..."
    />
  );
}
\`\`\`

### Inline Code
Use \`backticks\` for inline code snippets like \`const coffee = "latte";\` or \`pip install markdown\`.

---

## 📊 Table Support

DocuLatte renders beautiful, responsive tables with GitHub styling:

| Feature | Description | Status |
|---------|-------------|--------|
| **Real-time Preview** | See changes as you type | ✅ Implemented |
| **Draggable Splitter** | Resize panels dynamically | ✅ Implemented |
| **Snapshot System** | Save document versions | ✅ Implemented |
| **Share Links** | Generate shareable URLs | ✅ Implemented |
| **Image Support** | Embed images seamlessly | ✅ Implemented |
| **Task Lists** | Interactive checkboxes | ✅ Implemented |
| **Diff Viewer** | Visual change comparison | ✅ Implemented |

### Compatibility Matrix

| Browser | Desktop | Mobile | Notes |
|---------|---------|--------|-------|
| **Chrome** | ✅ Full | ✅ Full | Best performance |
| **Firefox** | ✅ Full | ✅ Full | Excellent compatibility |
| **Safari** | ✅ Full | ✅ Good | Minor styling differences |
| **Edge** | ✅ Full | ✅ Good | Modern Chromium base |

---

## 🖼️ Rich Media Support

### Images
DocuLatte handles images beautifully with automatic responsive sizing:

![Coffee beans and laptop](https://images.unsplash.com/photo-1504707748692-419802cf939d?w=800&h=400&fit=crop)

*A perfect workspace for brewing markdown*

![Markdown visualization](https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=600&h=300&fit=crop)

*Clean, organized, and ready for productivity*

---

## ✅ Task Management

DocuLatte supports interactive task lists:

- [x] ~~Design coffee-themed interface~~
- [x] ~~Implement real-time preview~~
- [x] ~~Add draggable splitter~~
- [x] ~~Create snapshot system~~
- [x] ~~Build diff viewer~~
- [x] ~~Add sharing capabilities~~
- [ ] Add dark mode toggle
- [ ] Implement collaborative editing
- [ ] Create mobile app

### Project Roadmap

- [x] **Phase 1:** Core editor functionality
- [x] **Phase 2:** Advanced markdown features  
- [x] **Phase 3:** Sharing and collaboration
- [ ] **Phase 4:** Mobile optimization
- [ ] **Phase 5:** Plugin system

---

## 🎯 Advanced Formatting

### Emphasis and Style
You can use **bold text**, *italic text*, ~~strikethrough~~, and even combine them like ***bold italic*** text.

### Blockquotes
> "DocuLatte has transformed how I write and share markdown documents. The real-time preview and sharing features are game-changers!"
> 
> — Happy User

> 💡 **Pro Tip:** Use the snapshot feature before making major changes to your document. You can always compare versions using the diff viewer.

### Horizontal Rules
Use horizontal rules to separate sections:

---

### Lists

**Ordered Lists:**
1. Import or create your markdown document
2. Choose your preferred layout (Code, Split, or Preview)
3. Start writing with real-time preview
4. Save snapshots of important versions
5. Share your perfectly brewed content

**Unordered Lists:**
- ☕ Coffee-themed design
- 🚀 Lightning-fast performance  
- 📱 Mobile-responsive interface
- 🔄 Real-time synchronization
- 💾 Automatic version tracking

---

## 🚀 Getting Started

### Quick Start Guide

1. **Open DocuLatte** in your web browser
2. **Choose your layout:**
   - **Code:** Focus on writing
   - **Split:** Write and preview simultaneously  
   - **Preview:** Review your formatted content
3. **Start typing** in the editor pane
4. **Save snapshots** to track your progress
5. **Share your work** with generated links

### Keyboard Shortcuts (Coming Soon)
- \`Cmd/Ctrl + S\` - Save snapshot
- \`Cmd/Ctrl + D\` - Toggle diff view
- \`Cmd/Ctrl + 1/2/3\` - Switch layouts
- \`Cmd/Ctrl + Enter\` - Full-screen preview

---

## 🤝 Perfect for Teams

DocuLatte is ideal for:
- **Documentation teams** creating technical guides
- **Content creators** drafting blog posts and articles
- **Developers** writing README files and documentation
- **Students** taking notes and creating reports
- **Writers** crafting manuscripts with formatting preview

---

## 🔗 Links and References

Visit our resources:
- [GitHub Repository](https://github.com/example/doculatte)
- [Documentation](https://doculatte.dev/docs)
- [Community Forum](https://community.doculatte.dev)
- [Feature Requests](https://github.com/example/doculatte/issues)

---

*Enjoy your perfectly brewed markdown experience with DocuLatte! ☕*`;
      let loadedFilename = "doculatte-overview.md";

      function renderAll() {
        const visible = stripHistory(currentMd);
        preview.innerHTML = mdToHtml(visible);
        status.textContent = `Chars: ${currentMd.length}`;
      }
      editor.addEventListener("input", () => {
        currentMd = editor.value;
        renderAll();
      });

      // Load file
      fileIn.addEventListener("change", async (e) => {
        const f = e.target.files?.[0];
        if (!f) return;
        loadedFilename = f.name;
        const text = await f.text();
        currentMd = text;
        editor.value = currentMd;
        renderAll();
        diffEl.hidden = true;
      });

      // New
      newBtn.addEventListener("click", () => {
        loadedFilename = "document.md";
        currentMd = "# Title\n\n";
        editor.value = currentMd;
        renderAll();
        diffEl.hidden = true;
      });

      // Save Snapshot
      saveSnapBtn.addEventListener("click", () => {
        const entries = parseHistory(currentMd);
        const visible = stripHistory(currentMd);
        const snap = makeSnapshotEntry(visible);
        const block = renderHistoryBlock([...entries, snap]);
        currentMd = `${visible}\n\n${block}\n`;
        editor.value = currentMd;
        renderAll();
        diffEl.hidden = true;
      });

      // Diff: Last Two snapshots (Vn-1 → Vn)
      diffLastTwoBtn.addEventListener("click", () => {
        const pair = lastTwoSnapshots(currentMd);
        if (!pair) {
          diffEl.innerHTML = "<em>Need ≥2 snapshots.</em>";
          diffEl.hidden = false;
          return;
        }
        const diffTxt = lineDiff(pair.a, pair.b);
        diffEl.innerHTML = renderDiffColored(diffTxt);
        diffEl.hidden = false;
      });

      // Diff: Working (editor) vs Last snapshot
      diffWorkingVsLastBtn.addEventListener("click", () => {
        const last = lastSnapshotText(currentMd);
        if (last == null) {
          diffEl.innerHTML = "<em>No snapshot yet.</em>";
          diffEl.hidden = false;
          return;
        }
        const working = stripHistory(editor.value);
        const diffTxt = lineDiff(last, working);
        diffEl.innerHTML = renderDiffColored(diffTxt);
        diffEl.hidden = false;
      });

      // Download
      downloadBtn.addEventListener("click", () => {
        const blob = new Blob([currentMd], { type: "text/markdown" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = loadedFilename.endsWith(".md") ? loadedFilename : "document.md";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      });

      // Share (copy encoded full file to clipboard)
      shareBtn.addEventListener("click", async () => {
        let payload = "";
        try {
          if ("CompressionStream" in window && "DecompressionStream" in window) {
            const gz = await gzipString(currentMd);
            payload = `MDLITE:v1|gz-b64url|` + b64urlFromBytes(gz);
          } else {
            payload = `MDLITE:v1|b64|` + b64enc(currentMd);
          }
          const link = location.origin + location.pathname + "#" + payload;
          await navigator.clipboard.writeText(link);
          status.textContent = "Copied share link to clipboard";
        } catch (e) {
          const link = location.origin + location.pathname + "#" + (payload || "MDLITE:v1|b64|" + b64enc(currentMd));
          try {
            const ok = window.prompt("Copy this link:", link);
            status.textContent = ok != null ? "Link shown for manual copy" : "Copy cancelled";
          } catch {}
        }
      });

      // Init
      editor.value = currentMd;
      renderAll();

      // ============== Layout toggle ==============
      function setLayout(mode) {
        appEl.dataset.layout = mode === "split" ? "split" : mode; // left | right or "split"
        layoutLeftBtn.setAttribute("aria-pressed", String(mode === "left"));
        layoutSplitBtn.setAttribute("aria-pressed", String(mode === "split"));
        layoutRightBtn.setAttribute("aria-pressed", String(mode === "right"));
        if (mode === "split") {
          // restore equal columns when returning to split
          appEl.style.gridTemplateColumns = "1fr 8px 1fr";
        } else {
          appEl.style.gridTemplateColumns = "1fr";
        }
        // Update URL parameter
        const url = new URL(window.location);
        if (mode === "split") {
          url.searchParams.delete("view");
        } else {
          url.searchParams.set("view", mode === "left" ? "code" : "preview");
        }
        window.history.replaceState({}, "", url);
      }
      layoutLeftBtn.addEventListener("click", () => setLayout("left"));
      layoutSplitBtn.addEventListener("click", () => setLayout("split"));
      layoutRightBtn.addEventListener("click", () => setLayout("right"));

      // Initialize layout from URL parameter (run after hash processing)
      function initLayoutFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const viewParam = urlParams.get("view");
        if (viewParam === "code") {
          setLayout("left");
        } else if (viewParam === "preview") {
          setLayout("right");
        } else {
          setLayout("split");
        }
      }

      // ============== Draggable splitter ==============
      let isDragging = false;
      gutter?.addEventListener("pointerdown", (e) => {
        isDragging = true;
        gutter.setPointerCapture(e.pointerId);
      });
      gutter?.addEventListener("pointerup", (e) => {
        isDragging = false;
        gutter.releasePointerCapture(e.pointerId);
      });
      gutter?.addEventListener("pointermove", (e) => {
        if (!isDragging) return;
        if (getComputedStyle(gutter).display === "none") return;
        const rect = appEl.getBoundingClientRect();
        const gutterWidth = 8;
        const minPaneWidth = 200;
        const maxLeftW = rect.width - gutterWidth - minPaneWidth;
        const x = Math.min(Math.max(e.clientX - rect.left, minPaneWidth), maxLeftW);
        const leftW = x;
        const rightW = rect.width - x - gutterWidth;
        appEl.style.gridTemplateColumns = `${leftW}px ${gutterWidth}px ${rightW}px`;
      });

      // On load: decode hash if present, then set layout
      (async function initFromHash() {
        const h = location.hash.slice(1);
        if (!h || !h.startsWith("MDLITE:")) {
          // No hash, just initialize layout from URL params
          initLayoutFromURL();
          return;
        }

        let loadedFromHash = false;
        try {
          const [tag, rest] = h.split("|", 2);
          const restAll = h.slice(tag.length + 1);
          if (restAll.startsWith("gz-b64url|")) {
            const data = restAll.slice("gz-b64url|".length);
            const bytes = await gunzipBytes(bytesFromB64url(data));
            const text = new TextDecoder().decode(bytes);
            currentMd = text;
            editor.value = currentMd;
            renderAll();
            loadedFromHash = true;
          } else if (restAll.startsWith("b64|")) {
            const data = restAll.slice("b64|".length);
            currentMd = b64dec(data);
            editor.value = currentMd;
            renderAll();
            loadedFromHash = true;
          }
          // Clean hash to avoid re-parsing on further edits
          history.replaceState(null, "", location.pathname + location.search);
        } catch (e) {
          console.warn("Failed to parse shared payload", e);
        }

        if (loadedFromHash) {
          // If we loaded content from a shared link, default to preview mode
          setLayout("right");
        } else {
          // Otherwise, use URL params
          initLayoutFromURL();
        }
      })();
    </script>
  </body>
</html>
